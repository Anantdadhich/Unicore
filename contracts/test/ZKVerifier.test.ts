import { expect } from "chai";
import  ethers from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { ZKVerifier } from "../typechain-types/index.js";
import { beforeEach, describe, it } from "node:test";

describe("ZKVerifier", function () {
  let zkVerifier: ZKVerifier;
  let owner: SignerWithAddress;
  let user: SignerWithAddress;

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();

    const ZKVerifierFactory = await ethers.getContractFactory("ZKVerifier");
    zkVerifier = await ZKVerifierFactory.deploy();
  });

  describe("Deployment", function () {
    it("Should set the correct owner", async function () {
      expect(await zkVerifier.owner()).to.equal(owner.address);
    });

    it("Should initialize with default verifying key", async function () {
      const verifyingKey = await zkVerifier.verifyingKey();
      expect(verifyingKey.alpha1).to.not.equal(ethers.ZeroAddress);
      expect(verifyingKey.beta2).to.not.equal(ethers.ZeroAddress);
      expect(verifyingKey.gamma2).to.not.equal(ethers.ZeroAddress);
      expect(verifyingKey.delta2).to.not.equal(ethers.ZeroAddress);
    });

    it("Should initialize with correct circuit parameters", async function () {
      expect(await zkVerifier.CIRCUIT_NUM_INPUTS()).to.equal(7);
      expect(await zkVerifier.CIRCUIT_NUM_OUTPUTS()).to.equal(1);
    });
  });

  describe("Proof Verification", function () {
    it("Should verify a valid proof", async function () {
      // Create a mock proof (in production, this would be generated by snarkjs)
      const mockProof = {
        a: [ethers.getBigInt("0x1234567890123456789012345678901234567890123456789012345678901234"),
            ethers.getBigInt("0x2345678901234567890123456789012345678901234567890123456789012345")],
        b: [[ethers.getBigInt("0x3456789012345678901234567890123456789012345678901234567890123456"),
             ethers.getBigInt("0x4567890123456789012345678901234567890123456789012345678901234567")],
            [ethers.getBigInt("0x5678901234567890123456789012345678901234567890123456789012345678"),
             ethers.getBigInt("0x6789012345678901234567890123456789012345678901234567890123456789")]],
        c: [ethers.getBigInt("0x7890123456789012345678901234567890123456789012345678901234567890"),
            ethers.getBigInt("0x8901234567890123456789012345678901234567890123456789012345678901")]
      };

      const publicInputs = [
        ethers.getBigInt("0x1000000000000000000000000000000000000000000000000000000000000000"), // tokenIn
        ethers.getBigInt("0x2000000000000000000000000000000000000000000000000000000000000000"), // tokenOut
        ethers.getBigInt("0x3000000000000000000000000000000000000000000000000000000000000000"), // amountIn
        ethers.getBigInt("0x4000000000000000000000000000000000000000000000000000000000000000"), // amountOut
        ethers.getBigInt("0x5000000000000000000000000000000000000000000000000000000000000000"), // userAddress
        ethers.getBigInt("0x6000000000000000000000000000000000000000000000000000000000000000"), // nonce
        ethers.getBigInt("0x7000000000000000000000000000000000000000000000000000000000000000")  // timestamp
      ];

      await expect(
        zkVerifier.verifyProof(mockProof, publicInputs)
      ).to.emit(zkVerifier, "ProofVerified")
        .withArgs(ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["tuple(uint256[2],uint256[2][2],uint256[2])", "uint256[7]"], [mockProof, publicInputs])));
    });

    it("Should mark proof as used when verifying and marking", async function () {
      const mockProof = {
        a: [ethers.getBigInt("0x1111111111111111111111111111111111111111111111111111111111111111"),
            ethers.getBigInt("0x2222222222222222222222222222222222222222222222222222222222222222")],
        b: [[ethers.getBigInt("0x3333333333333333333333333333333333333333333333333333333333333333"),
             ethers.getBigInt("0x4444444444444444444444444444444444444444444444444444444444444444")],
            [ethers.getBigInt("0x5555555555555555555555555555555555555555555555555555555555555555"),
             ethers.getBigInt("0x6666666666666666666666666666666666666666666666666666666666666666")]],
        c: [ethers.getBigInt("0x7777777777777777777777777777777777777777777777777777777777777777"),
            ethers.getBigInt("0x8888888888888888888888888888888888888888888888888888888888888888")]
      };

      const publicInputs = [
        ethers.getBigInt("0x1000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x2000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x3000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x4000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x5000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x6000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x7000000000000000000000000000000000000000000000000000000000000000")
      ];

      // First verification should succeed
      await expect(
        zkVerifier.verifyAndMarkUsed(mockProof, publicInputs)
      ).to.emit(zkVerifier, "ProofVerified");

      // Check that proof is marked as used
      const proofHash = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["tuple(uint256[2],uint256[2][2],uint256[2])", "uint256[7]"], [mockProof, publicInputs]));
      expect(await zkVerifier.isProofUsed(proofHash)).to.be.true;
    });

    it("Should reject already used proofs", async function () {
      const mockProof = {
        a: [ethers.getBigInt("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
            ethers.getBigInt("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb")],
        b: [[ethers.getBigInt("0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"),
             ethers.getBigInt("0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd")],
            [ethers.getBigInt("0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"),
             ethers.getBigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")]],
        c: [ethers.getBigInt("0x1111111111111111111111111111111111111111111111111111111111111111"),
            ethers.getBigInt("0x2222222222222222222222222222222222222222222222222222222222222222")]
      };

      const publicInputs = [
        ethers.getBigInt("0x1000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x2000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x3000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x4000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x5000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x6000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x7000000000000000000000000000000000000000000000000000000000000000")
      ];

      // First verification should succeed
      await zkVerifier.verifyAndMarkUsed(mockProof, publicInputs);

      // Second verification should fail
      await expect(
        zkVerifier.verifyAndMarkUsed(mockProof, publicInputs)
      ).to.be.revertedWith("Proof already used");
    });

    it("Should reject proofs with wrong number of inputs", async function () {
      const mockProof = {
        a: [ethers.getBigInt("0x1234567890123456789012345678901234567890123456789012345678901234"),
            ethers.getBigInt("0x2345678901234567890123456789012345678901234567890123456789012345")],
        b: [[ethers.getBigInt("0x3456789012345678901234567890123456789012345678901234567890123456"),
             ethers.getBigInt("0x4567890123456789012345678901234567890123456789012345678901234567")],
            [ethers.getBigInt("0x5678901234567890123456789012345678901234567890123456789012345678"),
             ethers.getBigInt("0x6789012345678901234567890123456789012345678901234567890123456789")]],
        c: [ethers.getBigInt("0x7890123456789012345678901234567890123456789012345678901234567890"),
            ethers.getBigInt("0x8901234567890123456789012345678901234567890123456789012345678901")]
      };

      // Wrong number of inputs
      const publicInputs = [
        ethers.getBigInt("0x1000000000000000000000000000000000000000000000000000000000000000"),
        ethers.getBigInt("0x2000000000000000000000000000000000000000000000000000000000000000")
      ];

      await expect(
        zkVerifier.verifyProof(mockProof, publicInputs)
      ).to.be.revertedWith("Invalid number of inputs");
    });
  });

  describe("Privacy Hash Generation", function () {
    it("Should generate consistent privacy hashes", async function () {
      const tokenIn = ethers.getAddress("0x1234567890123456789012345678901234567890");
      const tokenOut = ethers.getAddress("0x0987654321098765432109876543210987654321");
      const amountIn = ethers.parseEther("100");
      const amountOut = ethers.parseEther("250");
      const userAddress = ethers.getAddress("0x1111111111111111111111111111111111111111");
      const nonce = 12345;

      const hash1 = await zkVerifier.generatePrivacyHash(
        tokenIn,
        tokenOut,
        amountIn,
        amountOut,
        userAddress,
        nonce
      );

      const hash2 = await zkVerifier.generatePrivacyHash(
        tokenIn,
        tokenOut,
        amountIn,
        amountOut,
        userAddress,
        nonce
      );

      expect(hash1).to.equal(hash2);
    });

    it("Should generate different hashes for different inputs", async function () {
      const tokenIn = ethers.getAddress("0x1234567890123456789012345678901234567890");
      const tokenOut = ethers.getAddress("0x0987654321098765432109876543210987654321");
      const amountIn = ethers.parseEther("100");
      const amountOut = ethers.parseEther("250");
      const userAddress = ethers.getAddress("0x1111111111111111111111111111111111111111");
      const nonce1 = 12345;
      const nonce2 = 12346;

      const hash1 = await zkVerifier.generatePrivacyHash(
        tokenIn,
        tokenOut,
        amountIn,
        amountOut,
        userAddress,
        nonce1
      );

      const hash2 = await zkVerifier.generatePrivacyHash(
        tokenIn,
        tokenOut,
        amountIn,
        amountOut,
        userAddress,
        nonce2
      );

      expect(hash1).to.not.equal(hash2);
    });
  });

  describe("Admin Functions", function () {
    it("Should allow owner to update verifying key", async function () {
      const newVerifyingKey = {
        alpha1: [ethers.getBigInt("0x1111111111111111111111111111111111111111111111111111111111111111"),
                 ethers.getBigInt("0x2222222222222222222222222222222222222222222222222222222222222222")],
        beta2: [[ethers.getBigInt("0x3333333333333333333333333333333333333333333333333333333333333333"),
                 ethers.getBigInt("0x4444444444444444444444444444444444444444444444444444444444444444")],
                [ethers.getBigInt("0x5555555555555555555555555555555555555555555555555555555555555555"),
                 ethers.getBigInt("0x6666666666666666666666666666666666666666666666666666666666666666")]],
        gamma2: [[ethers.getBigInt("0x7777777777777777777777777777777777777777777777777777777777777777"),
                  ethers.getBigInt("0x8888888888888888888888888888888888888888888888888888888888888888")],
                 [ethers.getBigInt("0x9999999999999999999999999999999999999999999999999999999999999999"),
                  ethers.getBigInt("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")]],
        delta2: [[ethers.getBigInt("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"),
                  ethers.getBigInt("0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc")],
                 [ethers.getBigInt("0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"),
                  ethers.getBigInt("0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")]],
        ic: [[ethers.getBigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
              ethers.getBigInt("0x0000000000000000000000000000000000000000000000000000000000000000")]]
      };

      await expect(
        zkVerifier.updateVerifyingKey(newVerifyingKey)
      ).to.emit(zkVerifier, "VerifyingKeyUpdated");

      const updatedKey = await zkVerifier.verifyingKey();
      expect(updatedKey.alpha1[0]).to.equal(newVerifyingKey.alpha1[0]);
    });

    it("Should reject non-owner admin functions", async function () {
      const newVerifyingKey = {
        alpha1: [ethers.getBigInt("0x1111111111111111111111111111111111111111111111111111111111111111"),
                 ethers.getBigInt("0x2222222222222222222222222222222222222222222222222222222222222222")],
        beta2: [[ethers.getBigInt("0x3333333333333333333333333333333333333333333333333333333333333333"),
                 ethers.getBigInt("0x4444444444444444444444444444444444444444444444444444444444444444")],
                [ethers.getBigInt("0x5555555555555555555555555555555555555555555555555555555555555555"),
                 ethers.getBigInt("0x6666666666666666666666666666666666666666666666666666666666666666")]],
        gamma2: [[ethers.getBigInt("0x7777777777777777777777777777777777777777777777777777777777777777"),
                  ethers.getBigInt("0x8888888888888888888888888888888888888888888888888888888888888888")],
                 [ethers.getBigInt("0x9999999999999999999999999999999999999999999999999999999999999999"),
                  ethers.getBigInt("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")]],
        delta2: [[ethers.getBigInt("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"),
                  ethers.getBigInt("0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc")],
                 [ethers.getBigInt("0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"),
                  ethers.getBigInt("0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")]],
        ic: [[ethers.getBigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
              ethers.getBigInt("0x0000000000000000000000000000000000000000000000000000000000000000")]]
      };

      await expect(
        zkVerifier.connect(user).updateVerifyingKey(newVerifyingKey)
      ).to.be.revertedWithCustomError(zkVerifier, "OwnableUnauthorizedAccount");
    });
  });

  describe("View Functions", function () {
    it("Should return correct circuit parameters", async function () {
      const params = await zkVerifier.getCircuitParams();
      expect(params.numInputs).to.equal(7);
      expect(params.numOutputs).to.equal(1);
    });

    it("Should correctly check if proof is used", async function () {
      const proofHash = ethers.keccak256(ethers.toUtf8Bytes("test-proof"));
      
      expect(await zkVerifier.isProofUsed(proofHash)).to.be.false;
    });
  });
});
